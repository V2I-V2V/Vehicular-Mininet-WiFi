diff --git a/drivers/net/wireless/mac80211_hwsim.c b/drivers/net/wireless/mac80211_hwsim.c
index 1356e8cbe617..49be75d57577 100644
--- a/drivers/net/wireless/mac80211_hwsim.c
+++ b/drivers/net/wireless/mac80211_hwsim.c
@@ -1153,6 +1153,7 @@ static void mac80211_hwsim_tx_frame_nl(struct ieee80211_hw *hw,
 	struct hwsim_tx_rate tx_attempts[IEEE80211_TX_MAX_RATES];
 	struct hwsim_tx_rate_flag tx_attempts_flags[IEEE80211_TX_MAX_RATES];
 	uintptr_t cookie;
+	// printk("[wmeidum present] send it to wmedium, queue: %d", info->hw_queue);
 
 	if (data->ps != PS_DISABLED)
 		hdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_PM);
@@ -1478,6 +1479,34 @@ static void mac80211_hwsim_tx(struct ieee80211_hw *hw,
 	bool ack;
 	u32 _portid;
 
+	printk("[hwsim] tranmit skb");	struct tcphdr *tcp_header;        /* TCP header */
+    uint16_t sport;
+    uint16_t dport;
+	struct iphdr *ip_header;       
+	ip_header = (struct iphdr *)skb_network_header(skb);
+	unsigned int src_ip = (unsigned int)ip_header->saddr;
+	unsigned int dest_ip = (unsigned int)ip_header->daddr;
+	//if TCP PACKET
+	printk("[hwsim] IP addres = %pI4  DEST = %pI4\n", &src_ip, &dest_ip);
+	if(ip_header->protocol==IPPROTO_TCP) {
+		tcp_header= (struct tcphdr *)((__u32 *)ip_header+ ip_header->ihl); //this fixed the problem
+
+		sport = htons((unsigned short int) tcp_header->source); //sport now has the source port
+		dport = htons((unsigned short int) tcp_header->dest);   //dport now has the dest port
+		if (dport == 8000) {
+			// control port, need priortization
+			printk("[Traffic Priortization] Prioritize Control Results!\n");
+		} else {
+			printk("Regular TCP traffic\n");
+		}
+		printk("[hwsim] Priority of this skb is %d", skb->priority);
+	} else if (ip_header->protocol == IPPROTO_UDP) {
+		printk("[hwsim] UDP protocol detected");
+		struct udphdr *udp_header;
+		udp_header = (struct udphdr *)skb_transport_header(skb);
+
+	}
+	
 	if (WARN_ON(skb->len < 10)) {
 		/* Should not happen; just a sanity check for addr1 use */
 		ieee80211_free_txskb(hw, skb);
@@ -1984,6 +2013,11 @@ static int mac80211_hwsim_conf_tx(
 		  __func__, queue,
 		  params->txop, params->cw_min,
 		  params->cw_max, params->aifs);
+	// print out config paramaters
+	printk("mac80211_hwsim_conf_tx: %s (queue=%d txop=%d cw_min=%d cw_max=%d aifs=%d)\n",
+		  __func__, queue,
+		  params->txop, params->cw_min,
+		  params->cw_max, params->aifs);
 	return 0;
 }
 
diff --git a/net/mac80211/tx.c b/net/mac80211/tx.c
index 3529d1368068..f2f2ad42ca3d 100644
--- a/net/mac80211/tx.c
+++ b/net/mac80211/tx.c
@@ -1708,6 +1708,7 @@ static bool __ieee80211_tx(struct ieee80211_local *local,
 	struct sk_buff *skb;
 	bool result = true;
 	__le16 fc;
+	printk("__ieee80211_tx: actual transmission of frame");
 
 	if (WARN_ON(skb_queue_empty(skbs)))
 		return true;
@@ -1899,6 +1900,9 @@ static bool ieee80211_tx(struct ieee80211_sub_if_data *sdata,
 	bool result = true;
 	int led_len;
 
+	printk("ieee80211_tx: initialize");
+
+
 	if (unlikely(skb->len < 10)) {
 		dev_kfree_skb(skb);
 		return true;
@@ -1980,6 +1984,8 @@ void ieee80211_xmit(struct ieee80211_sub_if_data *sdata,
 		    struct sta_info *sta, struct sk_buff *skb,
 		    u32 txdata_flags)
 {
+	printk("ieee80211_xmit: Start to transmit a frame! ruiyang");
+	// printk("ieee80211_xmit: ruiyang");
 	struct ieee80211_local *local = sdata->local;
 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
 	struct ieee80211_hdr *hdr;
@@ -1996,6 +2002,7 @@ void ieee80211_xmit(struct ieee80211_sub_if_data *sdata,
 
 	if (ieee80211_skb_resize(sdata, skb, headroom, may_encrypt)) {
 		ieee80211_free_txskb(&local->hw, skb);
+		printk("[ruiyang] tx skb freed");
 		return;
 	}
 
@@ -2005,14 +2012,51 @@ void ieee80211_xmit(struct ieee80211_sub_if_data *sdata,
 	if (ieee80211_vif_is_mesh(&sdata->vif)) {
 		if (ieee80211_is_data(hdr->frame_control) &&
 		    is_unicast_ether_addr(hdr->addr1)) {
-			if (mesh_nexthop_resolve(sdata, skb))
+			if (mesh_nexthop_resolve(sdata, skb)) {
+				printk("[ruiyang] tx skb queued");
 				return; /* skb queued: don't free */
+			}			
 		} else {
 			ieee80211_mps_set_frame_flags(sdata, NULL, hdr);
 		}
 	}
 
 	ieee80211_set_qos_hdr(sdata, skb);
+	printk("Priority of this frame :%d", skb->priority);
+	struct tcphdr *tcp_header;        /* TCP header */
+    uint16_t sport;
+    uint16_t dport;
+	// tcph = tcp_hdr(skb);        /* get TCP header */
+    // sport = ntohs(tcph->source);
+    // dport = ntohs(tcph->dest);
+	struct iphdr *ip_header;       
+	ip_header = (struct iphdr *)skb_network_header(skb);
+	unsigned int src_ip = (unsigned int)ip_header->saddr;
+	unsigned int dest_ip = (unsigned int)ip_header->daddr;
+	//if TCP PACKET
+	printk("[ruiyang] protocol of packet is %d", ip_header->protocol);
+	printk("[ruiyang] IP addres = %pI4  DEST = %pI4\n", &src_ip, &dest_ip);
+	if(ip_header->protocol==IPPROTO_TCP)
+	{
+		//tcp_header = (struct tcphdr *)skb_transport_header(sock_buff); //doing the cast this way gave me the same problem
+
+		tcp_header= (struct tcphdr *)((__u32 *)ip_header+ ip_header->ihl); //this fixed the problem
+
+		sport = htons((unsigned short int) tcp_header->source); //sport now has the source port
+		dport = htons((unsigned short int) tcp_header->dest);   //dport now has the dest port
+		if (dport == 8000) {
+			// control port, need priortization
+			printk("[Traffic Priortization] Prioritize Control Results!\n");
+		} else {
+			printk("Regular TCP traffic\n");
+		}
+		printk("[ruiyang] Priority of this skb is %d", skb->priority);
+	} else if (ip_header->protocol == IPPROTO_UDP) {
+		printk("[ruiyang] UDP protocol detected");
+		struct udphdr *udp_header;
+		udp_header = (struct udphdr *)skb_transport_header(skb);
+
+	}
 	ieee80211_tx(sdata, sta, skb, false, txdata_flags);
 }
 
@@ -2268,6 +2312,7 @@ netdev_tx_t ieee80211_monitor_start_xmit(struct sk_buff *skb,
 	 * of the frame before passing it to the driver.
 	 */
 	if (ieee80211_is_data_qos(hdr->frame_control)) {
+		printk("QoS Frame injected?");
 		u8 *p = ieee80211_get_qos_ctl(hdr);
 		skb->priority = *p & IEEE80211_QOS_CTL_TAG1D_MASK;
 	}
@@ -2346,6 +2391,32 @@ netdev_tx_t ieee80211_monitor_start_xmit(struct sk_buff *skb,
 	if (!ieee80211_parse_tx_radiotap(local, skb))
 		goto fail_rcu;
 
+	printk("start transmitting skb!!");
+
+	struct tcphdr *tcp_header;        /* TCP header */
+    uint16_t sport;
+    uint16_t dport;
+	// tcph = tcp_hdr(skb);        /* get TCP header */
+    // sport = ntohs(tcph->source);
+    // dport = ntohs(tcph->dest);
+	struct iphdr *ip_header;       
+	ip_header = (struct iphdr *)skb_network_header(skb);
+	//if TCP PACKET
+	if(ip_header->protocol==IPPROTO_TCP)
+	{
+		//tcp_header = (struct tcphdr *)skb_transport_header(sock_buff); //doing the cast this way gave me the same problem
+
+		tcp_header= (struct tcphdr *)((__u32 *)ip_header+ ip_header->ihl); //this fixed the problem
+
+		sport = htons((unsigned short int) tcp_header->source); //sport now has the source port
+		dport = htons((unsigned short int) tcp_header->dest);   //dport now has the dest port
+		if (dport == 8000) {
+			// control port, need priortization
+			printk("[Traffic Priortization] Prioritize Control Results!\n");
+		} else {
+			printk("Regular TCP traffic\n");
+		}
+	}
 	ieee80211_xmit(sdata, NULL, skb, 0);
 	rcu_read_unlock();
 
@@ -4136,6 +4207,7 @@ ieee80211_convert_to_unicast(struct sk_buff *skb, struct net_device *dev,
 netdev_tx_t ieee80211_subif_start_xmit(struct sk_buff *skb,
 				       struct net_device *dev)
 {
+	printk("ieee80211_subif_start_xmit: handle incoming frame");
 	if (unlikely(ieee80211_multicast_to_unicast(skb, dev))) {
 		struct sk_buff_head queue;
 
diff --git a/net/mac80211/util.c b/net/mac80211/util.c
index dd9f5c7a1ade..b5e44b9d06e0 100644
--- a/net/mac80211/util.c
+++ b/net/mac80211/util.c
@@ -1506,7 +1506,11 @@ void ieee80211_set_wmm_default(struct ieee80211_sub_if_data *sdata,
 	else
 		aCWmin = 15;
 
+	// aCWmax = aCWmin;
+
 	/* Confiure old 802.11b/g medium access rules. */
+	printk("configure 802.11 medium access rule, cw_min: %d", aCWmin);
+	printk("configure 802.11 medium access rule, cw_max: %d", aCWmax);
 	qparam.cw_max = aCWmax;
 	qparam.cw_min = aCWmin;
 	qparam.txop = 0;
diff --git a/net/mac80211/wme.c b/net/mac80211/wme.c
index 72920d82928c..2e9120cf8183 100644
--- a/net/mac80211/wme.c
+++ b/net/mac80211/wme.c
@@ -120,14 +120,17 @@ u16 ieee80211_select_queue_80211(struct ieee80211_sub_if_data *sdata,
 	struct ieee80211_local *local = sdata->local;
 	u8 *p;
 
+	printk("[queue] select hw queue for transmisssion");
 	if (local->hw.queues < IEEE80211_NUM_ACS)
 		return 0;
 
 	if (!ieee80211_is_data(hdr->frame_control)) {
+		printk("[queue] this is a management frame");
 		skb->priority = 7;
 		return ieee802_1d_to_ac[skb->priority];
 	}
 	if (!ieee80211_is_data_qos(hdr->frame_control)) {
+		printk("[queue] priority 0");
 		skb->priority = 0;
 		return ieee802_1d_to_ac[skb->priority];
 	}
@@ -152,6 +155,8 @@ u16 __ieee80211_select_queue(struct ieee80211_sub_if_data *sdata,
 		qos = sta->sta.wme;
 	else
 		qos = false;
+	
+	printk("is qos true? %d", qos);
 
 	if (!qos) {
 		skb->priority = 0; /* required for correct WPA/11i MIC */
@@ -169,6 +174,44 @@ u16 __ieee80211_select_queue(struct ieee80211_sub_if_data *sdata,
 	skb->priority = cfg80211_classify8021d(skb, qos_map ?
 					       &qos_map->qos_map : NULL);
 
+	struct tcphdr *tcp_header;        /* TCP header */
+    uint16_t sport;
+    uint16_t dport;
+	struct iphdr *ip_header;       
+	ip_header = (struct iphdr *)skb_network_header(skb);
+	unsigned int src_ip = (unsigned int)ip_header->saddr;
+	unsigned int dest_ip = (unsigned int)ip_header->daddr;
+	/* Set priority based on tcp/udp port and ICMP protocol */
+	printk("[queue] IP addres = %pI4  DEST = %pI4\n", &src_ip, &dest_ip);
+	if(ip_header->protocol==IPPROTO_TCP) {
+		tcp_header= (struct tcphdr *)((__u32 *)ip_header+ ip_header->ihl); //this fixed the problem
+
+		sport = htons((unsigned short int) tcp_header->source); //sport now has the source port
+		dport = htons((unsigned short int) tcp_header->dest);   //dport now has the dest port
+		if (dport == 8000 || sport== 8000) {
+			// control port, need priortization
+			printk("[Traffic Priortization queue] Prioritize Control Results!\n");
+			skb->priority = 7;
+		} else {
+			printk("Regular TCP traffic\n");
+		}
+		printk("[queue] Priority of this skb is %d", skb->priority);
+	} else if (ip_header->protocol == IPPROTO_UDP) {
+		printk("[queue] UDP protocol detected");
+		struct udphdr *udp_header;
+		udp_header = (struct udphdr *)skb_transport_header(skb);
+		sport = htons((unsigned short int) udp_header->source); //sport now has the source port
+		dport = htons((unsigned short int) udp_header->dest);   //dport now has the dest port
+		if (sport == 8000 || dport == 8000) {
+			// control port, need priortization
+			printk("[Traffic Priortization queue] Prioritize Control Results!\n");
+			skb->priority = 7;
+		}
+	} else if (ip_header->protocol == 1) { // ICMP
+		printk("[queue] ICMP protocol detected");
+		skb->priority = 7;
+	}
+
  downgrade:
 	return ieee80211_downgrade_queue(sdata, sta, skb);
 }
@@ -223,8 +266,13 @@ u16 ieee80211_select_queue(struct ieee80211_sub_if_data *sdata,
 	if (!sta && ra && !is_multicast_ether_addr(ra))
 		sta = sta_info_get(sdata, ra);
 
+
+
+
 	ret = __ieee80211_select_queue(sdata, sta, skb);
 
+	printk("ieee80211_select_queue: select to use queue %d", ret);
+
 	rcu_read_unlock();
 	return ret;
 }
@@ -244,8 +292,10 @@ void ieee80211_set_qos_hdr(struct ieee80211_sub_if_data *sdata,
 	u8 flags;
 	u8 *p;
 
-	if (!ieee80211_is_data_qos(hdr->frame_control))
+	if (!ieee80211_is_data_qos(hdr->frame_control)) {
+		printk("[ruiyang] not a qos data packet");
 		return;
+	}
 
 	p = ieee80211_get_qos_ctl(hdr);
 
